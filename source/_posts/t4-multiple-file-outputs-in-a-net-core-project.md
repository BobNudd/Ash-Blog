---
title: T4 Multiple File Outputs in a .NET Core Project
date: 2018/11/03 11:15:00
tags: t4, c#
---

I recently needed to auto generate boilerplate classes for a project based upon reflection meta data. Having been a few years since I’d leveraged T4 for SQL Stored Proc generation and the awesome [T4MVC](https://github.com/T4MVC/T4MVC) template, surely there’s a shiny new method?

[Scripty](https://github.com/daveaglick/Scripty) comes up as an alternative scripting approach for code generation, unfortunately it’s having [major issues](https://github.com/daveaglick/Scripty/issues/127) with VS 2017 and the Roslyn compiler.

So, it looks like T4 Templating is still the way to go. However whilst writing the template, it appears that splitting code into multiple files and moving directories is quite a problem as templating standard behaviour is to nest files under the parent template.

### Prerequisites

First, we’re going to leverage the T4 Toolbox extension. Yes, this works in VS 2017 at the time of writing (I have update 15.8.9), you can find this here.

### Getting Started

So our strategy here is to have a Runner template and code generation template.

* Runner template – This will be responsible for initialisation of the code generate template, our method is to enumerate through a collection and pass data to our template
* Code generation template – This will contain our templating code
 

Please note – The below represents a basic example, and is not production code.

##### TemplateRunner.tt

{% codeblock lang:csharp %}
<#@ template language="C#" debug="false" #>			 //#A
<#@ output extension="cs" #>						 //#A
<#@ import namespace="System.Linq" #>				 //#A
<#@ import namespace="System.Text" #>				 //#A
<#@ import namespace="System.IO" #>					 //#A
<#@ import namespace="System.Collections.Generic" #> //#A
<#@ include file="BaseGeneratorApi.tt" #> //#B
<#
BaseGeneratorApi baseTemplate = new BaseGeneratorApi(); //#B
var currentFolder = new FileInfo(Host.ResolvePath(Host.TemplateFile)).DirectoryName; //#C
var webProject = Path.GetFullPath(Path.Combine(currentFolder, @"../", "src")); //#C


var apiControllerNames = File.ReadAllLines(Path.Combine(currentFolder, "bin", "Debug", "netcoreapp2.1", "webapinames.txt")); //#D

if(apiControllerNames != null && apiControllerNames.Any()) {
  
  foreach (string className in apiControllerNames)
  {
    baseTemplate.controllerName = className; //#E
    baseTemplate.controllerNameTitled = char.ToLower(className[0]) + className.Substring(1); //#E

    var controllerFileName = $"{className}Controller.cs";

    baseTemplate.RenderToFile(Path.Combine("Autogenerated", controllerFileName)); #//F
  }
}
#>
{% endcodeblock %}

Lets go through the code above:

* **#A** – We want to ouput .cs files, also we’ll need those namespaces to import the required classes for enumeration/file reading
* **#B** – Here we instantiate our code generation template, in this example it’s a template which generates a blank Web API controller
* **#C** – Since the templates base directory at runtime is within a sub directory of your VS folder, we need to do a little configuration, for this example we want to read a text file in our bin folder
* **#D** – Reading of a text file
* **#E** – We pass a few strings to own code generation template, since these will be the subject of said class
* **#F** – We call the RenderToFileMethod, passing a file path for our class

##### BaseGeneratorApi.tt

{% codeblock lang:csharp %}
<#@ output extension="cs" #>
<#@ include file="T4Toolbox.tt" #> //#A
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
public class BaseGeneratorRepository : CSharpTemplate //#B
{
public string repositoryName;
public string repositoryNameTitled;

public override string TransformText() //#B
{
base.TransformText();

#>

//All your code goes here!
[Route("api/[controller]")]
[Authorize]
public class <#= $"{controllerName}Controller" #> : ControllerBase   
{

}


<#+
return this.GenerationEnvironment.ToString();
}
}
#>
{% endcodeblock %}

As above:

* **#A** – Here we’ll leverage the helpers which T4 Toolbox providses, therefore you’ll in to include the file
* **#B** – We’ll want to inherit from the abstract class `CSharpTemplate` which is part on the [T4 toolbox](https://github.com/olegsych/T4Toolbox/blob/master/src/T4Toolbox/CSharpTemplate.cs). In our derived class we’ll access the `TransformText` method in the base class to append our additional code

You can have multiple code generation templates which are used within a single template runner, however it increases the scope of a problem occurring in the transformations, and therefore a 1:1 ratio is better.